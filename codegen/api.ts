/// <reference types="node" />
/**
 * Dive AR REST API
 * Dive Ad Resonance REST API provides a set of services which leverage obtaining client catalog info and its related contexts and situations data
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://rest.dive.tv/v1".replace(/\/+$/, "");

export type TokenStoreType = "webstorage" | "cookies";

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: any;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
}

/**
 * Catalog attribute
 */
export interface ARCatalogAttribute {
    /**
     * Attribute name
     */
    "name": string;
    /**
     * Attribute displayable description
     */
    "description": string;
    /**
     * List of available values for this attribute
     */
    "values": Array<string>;
}

/**
 * Catalog category
 */
export interface ARCatalogCategory {
    /**
     * Category name
     */
    "category": string;
    /**
     * List of taxonomies included in this category
     */
    "taxonomies": Array<ARCatalogTaxonomy>;
}

/**
 * Catalog movie information
 */
export interface ARCatalogMovie {
    /**
     * Movie identifier for the requester client
     */
    "client_movie_id": string;
    /**
     * Movie title in the request locale
     */
    "title": string;
    /**
     * Year of production
     */
    "year": number;
}

/**
 * Catalog actor / character
 */
export interface ARCatalogPerson {
    /**
     * Actor / character ID
     */
    "person_id": string;
    /**
     * Name of the actor or character
     */
    "name": string;
}

/**
 * Catalog serie information
 */
export interface ARCatalogSerie {
    /**
     * Serie identifier for the requester client
     */
    "client_serie_id": string;
    /**
     * Serie title in the request locale
     */
    "title": string;
    /**
     * Year of production for first season
     */
    "year": number;
    /**
     * Number of available seasons
     */
    "season_count": number;
}

/**
 * Catalog serie chapter information
 */
export interface ARCatalogSerieChapter {
    /**
     * Index of the chapter amongst season chapters, starting from 1
     */
    "chapter_index": number;
    /**
     * Movie ID for this chapter
     */
    "client_movie_id": string;
    /**
     * Chapter title in the requested locale
     */
    "title": string;
}

/**
 * Catalog serie seasons information
 */
export interface ARCatalogSerieSeason {
    /**
     * Index of the season amongst serie seasons, starting from 1
     */
    "season_index": number;
    /**
     * List of chapters of the season
     */
    "chapters": Array<ARCatalogSerieChapter>;
}

/**
 * Catalog taxonomy item
 */
export interface ARCatalogTaxonomy {
    /**
     * Taxonomy ID
     */
    "tx_id": string;
    /**
     * Taxonomy friendly name
     */
    "name": string;
    /**
     * Taxonomy node breadcrumb from root
     */
    "breadcrumb"?: string;
    /**
     * List of child nodes for this taxonomy node
     */
    "children"?: Array<ARCatalogTaxonomy>;
}

/**
 * Context search request
 */
export interface ARSearchRequest {
    /**
     * Optional list of searched movie and chapter IDs
     */
    "movie_ids"?: Array<string>;
    /**
     * Optional list of searched context taxonomy IDs
     */
    "taxonomy_ids"?: Array<string>;
    /**
     * Optional list of searched context actor and character IDs
     */
    "person_ids"?: Array<string>;
    /**
     * Optional list of searched context attributes and values
     */
    "attributes"?: Array<ARCatalogAttribute>;
}

/**
 * Context search results category
 */
export interface ARSearchResultCategory {
    /**
     * Result category name
     */
    "category": string;
    /**
     * Number of detected contexts under this category
     */
    "context_count"?: number;
    /**
     * List of taxonomies detected for this category
     */
    "taxonomies": Array<ARSearchResultTaxonomy>;
}

/**
 * Search results movie context
 */
export interface ARSearchResultContext {
    /**
     * Context start timestamp in seconds
     */
    "start_ts": number;
    /**
     * Context end timestamp in seconds
     */
    "end_ts": number;
    /**
     * List of key frame image URLs for this context
     */
    "kfts": Array<string>;
    "attributes"?: ARSearchResultContextAttributes;
}

/**
 * Additional attributes linked to a detected context
 */
export interface ARSearchResultContextAttributes {
    /**
     * Generic name for the context
     */
    "name"?: string;
    /**
     * Detected object brand
     */
    "brand"?: string;
    /**
     * Detected object model
     */
    "model"?: string;
    /**
     * Year(s) of production of a detected object
     */
    "year"?: string;
    /**
     * Name of the author of an artistic or cultural item
     */
    "author"?: string;
    /**
     * Name of the performing artist of a song
     */
    "artist"?: string;
    /**
     * Name of the performer of a song
     */
    "performer"?: string;
    /**
     * Country where a location belongs
     */
    "country"?: string;
    /**
     * City where a location belongs
     */
    "city"?: string;
    /**
     * Region where a location belongs
     */
    "region"?: string;
    /**
     * Street address of a location
     */
    "street"?: string;
}

/**
 * Context search results movie
 */
export interface ARSearchResultMovie {
    /**
     * Movie identifier for the client
     */
    "client_movie_id": string;
    /**
     * Movie title in the request locale
     */
    "title": string;
    /**
     * Movie video location URL
     */
    "video_url": string;
    /**
     * Video frame rate
     */
    "framerate"?: number;
    /**
     * Indicates if detected media is a movie or a chapter
     */
    "is_chapter"?: boolean;
    /**
     * Index of the season where this chapter belongs, only if is_chapter = true
     */
    "season_index"?: number;
    /**
     * Index of this chapter amongst season chapters, only if is_chapter = true
     */
    "chapter_index"?: number;
    /**
     * Title of the serie where this chapter belongs, only if is_chapter = true
     */
    "serie_title"?: string;
    /**
     * List of contexts detected on this movie related to the parent taxonomy (returned on context search)
     */
    "contexts"?: Array<ARSearchResultContext>;
    /**
     * List of movie scenes which fulfill search terms (returned on scene search)
     */
    "scenes"?: Array<ARSearchResultScene>;
}

/**
 * Search results movie scene
 */
export interface ARSearchResultScene {
    /**
     * Scene ID
     */
    "sc_id": string;
    /**
     * Scene title
     */
    "title": string;
    /**
     * Scene start timestamp in seconds
     */
    "start_ts": number;
    /**
     * Scene end timestamp in seconds
     */
    "end_ts": number;
    /**
     * List of key frame image URLs for this scene
     */
    "kfts": Array<string>;
}

/**
 * Context search results taxonomy item
 */
export interface ARSearchResultTaxonomy {
    /**
     * Taxonomy ID
     */
    "tx_id": string;
    /**
     * Taxonomy friendly name
     */
    "name": string;
    /**
     * List of taxonomy nodes traversed from the root to this item
     */
    "breadcrumb": Array<string>;
    /**
     * Number of detected contexts under this taxonomy
     */
    "context_count"?: number;
    /**
     * List of movies where this taxonomy has been detected
     */
    "movies": Array<ARSearchResultMovie>;
}

/**
 * API access token
 */
export interface AccessToken {
    /**
     * Auth token, must be included on every API request
     */
    "access_token"?: string;
    /**
     * Token type
     */
    "token_type"?: AccessTokenTokenTypeEnum;
    /**
     * Allows to issue new access tokens without resending client credentials
     */
    "refresh_token"?: string;
    /**
     * Expiration time (in seconds).
     */
    "expires_in"?: number;
    /**
     * Granted auth scope
     */
    "scope"?: AccessTokenScopeEnum;
}

export type AccessTokenTokenTypeEnum = "bearer";
export type AccessTokenScopeEnum = "device";
/**
 * Authentication error description
 */
export interface AuthError {
    /**
     * Short error identifier
     */
    "error"?: string;
    /**
     * Extended error description
     */
    "error_description"?: string;
}

/**
 * Client User registration data request
 */
export interface ClientRegistrationDataRequest {
    /**
     * user name
     */
    "username"?: string;
    /**
     * password in MD5 format
     */
    "password"?: string;
    /**
     * client id
     */
    "client_id"?: string;
}

/**
 * User registration data request
 */
export interface RegistrationDataRequest {
    /**
     * User name
     */
    "username": string;
    /**
     * User password in MD5 format
     */
    "password": string;
}



/**
 * DefaultApi - fetch parameter creator
 */
export const DefaultApiFetchParamCreator = {
    /**
     * Returns the list of actors which are ready for AR analysis on an optional subset of movies
     * @summary List AR-available actors
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
     */
    getARActors(params: {  "authorization": string; "acceptLanguage"?: string; "movieIds"?: Array<string>; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getARActors");
        }
        const baseUrl = `/ar/actors`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = Object.assign({}, urlObj.query, {
            "movie_ids": params["movieIds"],
        });
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns the list of attributes and values on an optional subset of movies
     * @summary List AR-available context attributes
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
     */
    getARAttributes(params: {  "authorization": string; "acceptLanguage"?: string; "movieIds"?: Array<string>; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getARAttributes");
        }
        const baseUrl = `/ar/attributes`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = Object.assign({}, urlObj.query, {
            "movie_ids": params["movieIds"],
        });
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns the list of characters which are ready for AR analysis on an optional subset of movies
     * @summary List AR-available characters
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
     */
    getARCharacters(params: {  "authorization": string; "acceptLanguage"?: string; "movieIds"?: Array<string>; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getARCharacters");
        }
        const baseUrl = `/ar/characters`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = Object.assign({}, urlObj.query, {
            "movie_ids": params["movieIds"],
        });
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns the list of movies which are ready for AR analysis
     * @summary List AR-available movies
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     */
    getARMovies(params: {  "authorization": string; "acceptLanguage"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getARMovies");
        }
        const baseUrl = `/ar/movies`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns the list of seasons and chapters which are available for AR analysis for a given client serie
     * @summary List serie seasons and chapters
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientSerieId Client serie identifier
     * @param acceptLanguage Client locale, as language-country
     */
    getARSerieSeasons(params: {  "authorization": string; "clientSerieId": string; "acceptLanguage"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getARSerieSeasons");
        }
        // verify required parameter "clientSerieId" is set
        if (params["clientSerieId"] == null) {
            throw new Error("Missing required parameter clientSerieId when calling getARSerieSeasons");
        }
        const baseUrl = `/ar/series/{client_serie_id}/seasons`
            .replace(`{${"client_serie_id"}}`, `${ params["clientSerieId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns the list of series which are ready for AR analysis
     * @summary List AR-available series
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     */
    getARSeries(params: {  "authorization": string; "acceptLanguage"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getARSeries");
        }
        const baseUrl = `/ar/series`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns the list of taxonomies on an optional subset of movies
     * @summary List AR-available taxonomies
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
     */
    getARTaxonomies(params: {  "authorization": string; "acceptLanguage"?: string; "movieIds"?: Array<string>; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getARTaxonomies");
        }
        const baseUrl = `/ar/taxonomies`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = Object.assign({}, urlObj.query, {
            "movie_ids": params["movieIds"],
        });
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Registers a new user into Add Resonance application using the user name and provided password
     * @summary Register user account
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param registrationDataRequest User registration data
     */
    postRegisterUser(params: {  "authorization": string; "registrationDataRequest": RegistrationDataRequest; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling postRegisterUser");
        }
        // verify required parameter "registrationDataRequest" is set
        if (params["registrationDataRequest"] == null) {
            throw new Error("Missing required parameter registrationDataRequest when calling postRegisterUser");
        }
        const baseUrl = `/ar/register/user`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["registrationDataRequest"]) {
            fetchOptions.body = JSON.stringify(params["registrationDataRequest"] || {});
        }
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns the list of contexts which fulfill the search terms, filtered at movie level and grouped by taxonomy branch
     * @summary Search contexts at movie level
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param searchRequest Search terms
     */
    postSearch(params: {  "authorization": string; "acceptLanguage"?: string; "searchRequest"?: ARSearchRequest; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling postSearch");
        }
        const baseUrl = `/ar/search/contexts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["searchRequest"]) {
            fetchOptions.body = JSON.stringify(params["searchRequest"] || {});
        }
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns the list of scenes which fulfill the requested search filters, grouped by movie
     * @summary Search contexts at scene level
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param searchRequest Search terms
     */
    postSearchScenes(params: {  "authorization": string; "acceptLanguage"?: string; "searchRequest"?: ARSearchRequest; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling postSearchScenes");
        }
        const baseUrl = `/ar/search/scenes`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["searchRequest"]) {
            fetchOptions.body = JSON.stringify(params["searchRequest"] || {});
        }
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * The token endpoint is used to obtain access tokens which allow clients to make API requests
     * @summary Token endpoint
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param grantType Grant type used to obtain the token
     * @param acceptLanguage Client locale, as language-country
     * @param username User name
     * @param password User password
     * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
     */
    postToken(params: {  "authorization": string; "grantType": string; "acceptLanguage"?: string; "username"?: string; "password"?: string; "refreshToken"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling postToken");
        }
        // verify required parameter "grantType" is set
        if (params["grantType"] == null) {
            throw new Error("Missing required parameter grantType when calling postToken");
        }
        const baseUrl = `/token`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = Object.assign({}, urlObj.query, {
            "grant_type": params["grantType"],
        });
        let fetchOptions: RequestInit = Object.assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "username": params["username"],
            "password": params["password"],
            "refresh_token": params["refreshToken"],
        });
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Registers a user into Dive apis using the client_id, user name and provided password
     * @summary Token endpoint
     * @param tokenDataRequest User registration data
     */
    postTokenClientUser(params: {  "tokenDataRequest": ClientRegistrationDataRequest; }, options?: any): FetchArgs {
        // verify required parameter "tokenDataRequest" is set
        if (params["tokenDataRequest"] == null) {
            throw new Error("Missing required parameter tokenDataRequest when calling postTokenClientUser");
        }
        const baseUrl = `/token_client_user`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["tokenDataRequest"]) {
            fetchOptions.body = JSON.stringify(params["tokenDataRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = Object.assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = {
    /**
     * Returns the list of actors which are ready for AR analysis on an optional subset of movies
     * @summary List AR-available actors
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
     */
    getARActors(params: { "authorization": string; "acceptLanguage"?: string; "movieIds"?: Array<string>;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Array<ARCatalogPerson>> {
        const fetchArgs = DefaultApiFetchParamCreator.getARActors(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns the list of attributes and values on an optional subset of movies
     * @summary List AR-available context attributes
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
     */
    getARAttributes(params: { "authorization": string; "acceptLanguage"?: string; "movieIds"?: Array<string>;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Array<ARCatalogAttribute>> {
        const fetchArgs = DefaultApiFetchParamCreator.getARAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns the list of characters which are ready for AR analysis on an optional subset of movies
     * @summary List AR-available characters
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
     */
    getARCharacters(params: { "authorization": string; "acceptLanguage"?: string; "movieIds"?: Array<string>;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Array<ARCatalogPerson>> {
        const fetchArgs = DefaultApiFetchParamCreator.getARCharacters(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns the list of movies which are ready for AR analysis
     * @summary List AR-available movies
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     */
    getARMovies(params: { "authorization": string; "acceptLanguage"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Array<ARCatalogMovie>> {
        const fetchArgs = DefaultApiFetchParamCreator.getARMovies(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns the list of seasons and chapters which are available for AR analysis for a given client serie
     * @summary List serie seasons and chapters
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientSerieId Client serie identifier
     * @param acceptLanguage Client locale, as language-country
     */
    getARSerieSeasons(params: { "authorization": string; "clientSerieId": string; "acceptLanguage"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Array<ARCatalogSerieSeason>> {
        const fetchArgs = DefaultApiFetchParamCreator.getARSerieSeasons(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns the list of series which are ready for AR analysis
     * @summary List AR-available series
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     */
    getARSeries(params: { "authorization": string; "acceptLanguage"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Array<ARCatalogSerie>> {
        const fetchArgs = DefaultApiFetchParamCreator.getARSeries(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns the list of taxonomies on an optional subset of movies
     * @summary List AR-available taxonomies
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
     */
    getARTaxonomies(params: { "authorization": string; "acceptLanguage"?: string; "movieIds"?: Array<string>;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Array<ARCatalogCategory>> {
        const fetchArgs = DefaultApiFetchParamCreator.getARTaxonomies(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Registers a new user into Add Resonance application using the user name and provided password
     * @summary Register user account
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param registrationDataRequest User registration data
     */
    postRegisterUser(params: { "authorization": string; "registrationDataRequest": RegistrationDataRequest;  }, options?: any): (fetch?: any, basePath?: string) => Promise<any> {
        const fetchArgs = DefaultApiFetchParamCreator.postRegisterUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns the list of contexts which fulfill the search terms, filtered at movie level and grouped by taxonomy branch
     * @summary Search contexts at movie level
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param searchRequest Search terms
     */
    postSearch(params: { "authorization": string; "acceptLanguage"?: string; "searchRequest"?: ARSearchRequest;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Array<ARSearchResultCategory>> {
        const fetchArgs = DefaultApiFetchParamCreator.postSearch(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns the list of scenes which fulfill the requested search filters, grouped by movie
     * @summary Search contexts at scene level
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param searchRequest Search terms
     */
    postSearchScenes(params: { "authorization": string; "acceptLanguage"?: string; "searchRequest"?: ARSearchRequest;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Array<ARSearchResultMovie>> {
        const fetchArgs = DefaultApiFetchParamCreator.postSearchScenes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * The token endpoint is used to obtain access tokens which allow clients to make API requests
     * @summary Token endpoint
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param grantType Grant type used to obtain the token
     * @param acceptLanguage Client locale, as language-country
     * @param username User name
     * @param password User password
     * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
     */
    postToken(params: { "authorization": string; "grantType": string; "acceptLanguage"?: string; "username"?: string; "password"?: string; "refreshToken"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = DefaultApiFetchParamCreator.postToken(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Registers a user into Dive apis using the client_id, user name and provided password
     * @summary Token endpoint
     * @param tokenDataRequest User registration data
     */
    postTokenClientUser(params: { "tokenDataRequest": ClientRegistrationDataRequest;  }, options?: any): (fetch?: any, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = DefaultApiFetchParamCreator.postTokenClientUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * Returns the list of actors which are ready for AR analysis on an optional subset of movies
     * @summary List AR-available actors
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
     */
    getARActors(params: {  "authorization": string; "acceptLanguage"?: string; "movieIds"?: Array<string>; }, options?: any) {
        return DefaultApiFp.getARActors(params, options)(this.fetch, this.basePath);
    }
    /**
     * Returns the list of attributes and values on an optional subset of movies
     * @summary List AR-available context attributes
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
     */
    getARAttributes(params: {  "authorization": string; "acceptLanguage"?: string; "movieIds"?: Array<string>; }, options?: any) {
        return DefaultApiFp.getARAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * Returns the list of characters which are ready for AR analysis on an optional subset of movies
     * @summary List AR-available characters
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
     */
    getARCharacters(params: {  "authorization": string; "acceptLanguage"?: string; "movieIds"?: Array<string>; }, options?: any) {
        return DefaultApiFp.getARCharacters(params, options)(this.fetch, this.basePath);
    }
    /**
     * Returns the list of movies which are ready for AR analysis
     * @summary List AR-available movies
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     */
    getARMovies(params: {  "authorization": string; "acceptLanguage"?: string; }, options?: any) {
        return DefaultApiFp.getARMovies(params, options)(this.fetch, this.basePath);
    }
    /**
     * Returns the list of seasons and chapters which are available for AR analysis for a given client serie
     * @summary List serie seasons and chapters
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientSerieId Client serie identifier
     * @param acceptLanguage Client locale, as language-country
     */
    getARSerieSeasons(params: {  "authorization": string; "clientSerieId": string; "acceptLanguage"?: string; }, options?: any) {
        return DefaultApiFp.getARSerieSeasons(params, options)(this.fetch, this.basePath);
    }
    /**
     * Returns the list of series which are ready for AR analysis
     * @summary List AR-available series
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     */
    getARSeries(params: {  "authorization": string; "acceptLanguage"?: string; }, options?: any) {
        return DefaultApiFp.getARSeries(params, options)(this.fetch, this.basePath);
    }
    /**
     * Returns the list of taxonomies on an optional subset of movies
     * @summary List AR-available taxonomies
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
     */
    getARTaxonomies(params: {  "authorization": string; "acceptLanguage"?: string; "movieIds"?: Array<string>; }, options?: any) {
        return DefaultApiFp.getARTaxonomies(params, options)(this.fetch, this.basePath);
    }
    /**
     * Registers a new user into Add Resonance application using the user name and provided password
     * @summary Register user account
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param registrationDataRequest User registration data
     */
    postRegisterUser(params: {  "authorization": string; "registrationDataRequest": RegistrationDataRequest; }, options?: any) {
        return DefaultApiFp.postRegisterUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * Returns the list of contexts which fulfill the search terms, filtered at movie level and grouped by taxonomy branch
     * @summary Search contexts at movie level
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param searchRequest Search terms
     */
    postSearch(params: {  "authorization": string; "acceptLanguage"?: string; "searchRequest"?: ARSearchRequest; }, options?: any) {
        return DefaultApiFp.postSearch(params, options)(this.fetch, this.basePath);
    }
    /**
     * Returns the list of scenes which fulfill the requested search filters, grouped by movie
     * @summary Search contexts at scene level
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param searchRequest Search terms
     */
    postSearchScenes(params: {  "authorization": string; "acceptLanguage"?: string; "searchRequest"?: ARSearchRequest; }, options?: any) {
        return DefaultApiFp.postSearchScenes(params, options)(this.fetch, this.basePath);
    }
    /**
     * The token endpoint is used to obtain access tokens which allow clients to make API requests
     * @summary Token endpoint
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param grantType Grant type used to obtain the token
     * @param acceptLanguage Client locale, as language-country
     * @param username User name
     * @param password User password
     * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
     */
    postToken(params: {  "authorization": string; "grantType": string; "acceptLanguage"?: string; "username"?: string; "password"?: string; "refreshToken"?: string; }, options?: any) {
        return DefaultApiFp.postToken(params, options)(this.fetch, this.basePath);
    }
    /**
     * Registers a user into Dive apis using the client_id, user name and provided password
     * @summary Token endpoint
     * @param tokenDataRequest User registration data
     */
    postTokenClientUser(params: {  "tokenDataRequest": ClientRegistrationDataRequest; }, options?: any) {
        return DefaultApiFp.postTokenClientUser(params, options)(this.fetch, this.basePath);
    }
}

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (fetch?: any, basePath?: string) {
    return {
        /**
         * Returns the list of actors which are ready for AR analysis on an optional subset of movies
         * @summary List AR-available actors
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param acceptLanguage Client locale, as language-country
         * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
         */
        getARActors(params: {  "authorization": string; "acceptLanguage"?: string; "movieIds"?: Array<string>; }, options?: any) {
            return DefaultApiFp.getARActors(params, options)(fetch, basePath);
        },
        /**
         * Returns the list of attributes and values on an optional subset of movies
         * @summary List AR-available context attributes
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param acceptLanguage Client locale, as language-country
         * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
         */
        getARAttributes(params: {  "authorization": string; "acceptLanguage"?: string; "movieIds"?: Array<string>; }, options?: any) {
            return DefaultApiFp.getARAttributes(params, options)(fetch, basePath);
        },
        /**
         * Returns the list of characters which are ready for AR analysis on an optional subset of movies
         * @summary List AR-available characters
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param acceptLanguage Client locale, as language-country
         * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
         */
        getARCharacters(params: {  "authorization": string; "acceptLanguage"?: string; "movieIds"?: Array<string>; }, options?: any) {
            return DefaultApiFp.getARCharacters(params, options)(fetch, basePath);
        },
        /**
         * Returns the list of movies which are ready for AR analysis
         * @summary List AR-available movies
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param acceptLanguage Client locale, as language-country
         */
        getARMovies(params: {  "authorization": string; "acceptLanguage"?: string; }, options?: any) {
            return DefaultApiFp.getARMovies(params, options)(fetch, basePath);
        },
        /**
         * Returns the list of seasons and chapters which are available for AR analysis for a given client serie
         * @summary List serie seasons and chapters
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param clientSerieId Client serie identifier
         * @param acceptLanguage Client locale, as language-country
         */
        getARSerieSeasons(params: {  "authorization": string; "clientSerieId": string; "acceptLanguage"?: string; }, options?: any) {
            return DefaultApiFp.getARSerieSeasons(params, options)(fetch, basePath);
        },
        /**
         * Returns the list of series which are ready for AR analysis
         * @summary List AR-available series
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param acceptLanguage Client locale, as language-country
         */
        getARSeries(params: {  "authorization": string; "acceptLanguage"?: string; }, options?: any) {
            return DefaultApiFp.getARSeries(params, options)(fetch, basePath);
        },
        /**
         * Returns the list of taxonomies on an optional subset of movies
         * @summary List AR-available taxonomies
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param acceptLanguage Client locale, as language-country
         * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
         */
        getARTaxonomies(params: {  "authorization": string; "acceptLanguage"?: string; "movieIds"?: Array<string>; }, options?: any) {
            return DefaultApiFp.getARTaxonomies(params, options)(fetch, basePath);
        },
        /**
         * Registers a new user into Add Resonance application using the user name and provided password
         * @summary Register user account
         * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
         * @param registrationDataRequest User registration data
         */
        postRegisterUser(params: {  "authorization": string; "registrationDataRequest": RegistrationDataRequest; }, options?: any) {
            return DefaultApiFp.postRegisterUser(params, options)(fetch, basePath);
        },
        /**
         * Returns the list of contexts which fulfill the search terms, filtered at movie level and grouped by taxonomy branch
         * @summary Search contexts at movie level
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param acceptLanguage Client locale, as language-country
         * @param searchRequest Search terms
         */
        postSearch(params: {  "authorization": string; "acceptLanguage"?: string; "searchRequest"?: ARSearchRequest; }, options?: any) {
            return DefaultApiFp.postSearch(params, options)(fetch, basePath);
        },
        /**
         * Returns the list of scenes which fulfill the requested search filters, grouped by movie
         * @summary Search contexts at scene level
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param acceptLanguage Client locale, as language-country
         * @param searchRequest Search terms
         */
        postSearchScenes(params: {  "authorization": string; "acceptLanguage"?: string; "searchRequest"?: ARSearchRequest; }, options?: any) {
            return DefaultApiFp.postSearchScenes(params, options)(fetch, basePath);
        },
        /**
         * The token endpoint is used to obtain access tokens which allow clients to make API requests
         * @summary Token endpoint
         * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
         * @param grantType Grant type used to obtain the token
         * @param acceptLanguage Client locale, as language-country
         * @param username User name
         * @param password User password
         * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
         */
        postToken(params: {  "authorization": string; "grantType": string; "acceptLanguage"?: string; "username"?: string; "password"?: string; "refreshToken"?: string; }, options?: any) {
            return DefaultApiFp.postToken(params, options)(fetch, basePath);
        },
        /**
         * Registers a user into Dive apis using the client_id, user name and provided password
         * @summary Token endpoint
         * @param tokenDataRequest User registration data
         */
        postTokenClientUser(params: {  "tokenDataRequest": ClientRegistrationDataRequest; }, options?: any) {
            return DefaultApiFp.postTokenClientUser(params, options)(fetch, basePath);
        },
    };
};

/**
* CustomAPI - extended object-oriented interface
*/
export class CustomAPI extends DefaultApi {
  public locale: string = "en-US";
  private apiKey: string;
  private deviceId: string = "";
  private storeTokenType: TokenStoreType = "webstorage";
  private tokenName: string = "dive_token";
  private diveTokenRefreshInterval: number | undefined;
  protected noAuthServices: string[] = [];
  protected environment: string = "PRO";

  constructor(params: { environment: "DEV" | "PRE" | "PRO", tokenName?: string, storeToken?: TokenStoreType, apiKey: string, deviceId?: string, fetch?: any } = { environment: "PRO", storeToken: "webstorage", tokenName: "dive_token", apiKey: ""}) {
    super(params.fetch, BASE_PATH);
    if (params.apiKey === "") {
      console.error("You should provide an apiKey in the params");
      throw new Error("You should provide an apiKey in the params");
    }
    this.apiKey = params.apiKey;
    if (params.deviceId) {
        this.setDeviceId(params.deviceId);
    }
    if (params.environment) {
      this.setEnvironment(params.environment);
    }
    if (params.storeToken) {
      this.storeTokenType = params.storeToken;
    }
    if (params.tokenName) {
      this.tokenName = params.tokenName;
    }
  }

  public setDeviceId(deviceId: string) {
    this.deviceId = deviceId;
  }

  public setEnvironment(env: "DEV" | "PRE" | "PRO") {
    this.environment = env;
    switch (env) {
        case "DEV":
            this.basePath = BASE_PATH.replace("https://", "https://dev-");
        break;
        case "PRE":
            this.basePath = BASE_PATH.replace("https://", "https://pre-");
        break;
        case "PRO":
        default:
            this.basePath = BASE_PATH;
        break;
    }
  }
  public setLocale(locale: string) {
      this.locale = locale;
  }
  public getLocale() {
      return this.locale;
  }
  public gatherCommonHeaders(params?: any) {
    const newParams: any = {};
    if (!params) {
        params = {};
    }
    if (params["connection"] == null) {
        newParams.connection = "keep-alive";
    }
    if (params["acceptEncoding"] == null) {
        newParams.acceptEncoding = "gzip, deflate";
    }
    if (params["authorization"] == null && this.getSavedToken()) {
        newParams.authorization = `${this.getSavedToken().token_type.substring(0,1).toUpperCase()}${this.getSavedToken().token_type.substring(1)} ${this.getSavedToken().access_token}`;
    } else {
        newParams.authorization = `Basic ${this.apiKey}`;
    }
    /*
    if (params.acceptLanguage == null && this.locale !== null) {
        newParams.acceptLanguage = this.locale;
    }
    if (params["Accept-Language"] == null && this.locale !== null) {
        newParams["Accept-Language"] = this.locale;
    }*/
    /*Trying to set locale*/
    if ( this.locale != null) {
      newParams.acceptLanguage = this.locale;

      if(params.acceptLanguage != null && this.locale !== params.acceptLanguage){
        newParams.acceptLanguage += ',' + params.acceptLanguage;
      }else if(params['Accept-Language'] != null && this.locale !== params.acceptLanguage){
        newParams.acceptLanguage += ',' + params['Accept-Language'];
      }

      params.acceptLanguage = newParams.acceptLanguage;
    }
    return Object.assign({}, newParams, params);
  }
  public writeToken(newToken: AccessToken) {
    if (newToken) {
      switch (this.storeTokenType) {
        case "cookies":
          this.writeTokenToCookie(newToken);
          break;
        default:
          this.writeTokenToWebStorage(newToken);
          break;
      }
      if (this.diveTokenRefreshInterval) {
        window.clearInterval(this.diveTokenRefreshInterval);
        this.diveTokenRefreshInterval = undefined;
      }
      if (newToken.expires_in) {
        this.diveTokenRefreshInterval = window.setInterval(this.refreshToken.bind(this), (Math.max(10000, newToken.expires_in - 60) * 1000) as any); // 60 seconds before expiration (in ms)
      }
    }
  }
  private writeTokenToCookie(newToken: AccessToken) {
    return this.setCookie(this.tokenName, JSON.stringify(newToken), newToken.expires_in!);
  }
  private writeTokenToWebStorage(newToken: AccessToken) {
    if (window.localStorage) {
      window.localStorage.setItem(this.tokenName, JSON.stringify(newToken));
    }
  }
  public deleteSavedToken() {
    switch (this.storeTokenType) {
      case "cookies":
        this.deleteTokenFromCookies();
        break;
      default:
        this.deleteTokenFromWebStorage();
        break;
    }
  }
  private deleteTokenFromWebStorage() {
      if (window.localStorage) {
          window.localStorage.removeItem(this.tokenName);
      }
  }
  private deleteTokenFromCookies() {
    document.cookie = this.tokenName + "=;expires=Thu, 01 Jan 1970 00:00:01 GMT;";
  }
  public getSavedToken() {
    switch (this.storeTokenType) {
      case "cookies":
        return this.getTokenFromCookies();
      default:
        if (this.getTokenFromWebStorage()) {
            return JSON.parse(this.getTokenFromWebStorage() as string);
        }
        break;
    }
  }
  private getTokenFromCookies(): AccessToken | undefined | null {
    const token = this.getCookie(this.tokenName);
    if (token) {
      try {
          return JSON.parse(token) as AccessToken;
      } catch (e) {
          return undefined;
      }
    } else {
      return undefined;
    }
  }
  private getTokenFromWebStorage(): AccessToken | undefined | null {
    if (window.localStorage) {
      try {
        return window.localStorage.getItem(this.tokenName) as AccessToken;
      } catch (e) {
        return undefined;
      }
    }
  }
  public refreshToken() {
    const currToken = this.getSavedToken();
    let auth: string = `Basic ${this.apiKey}`;
    if (currToken && currToken.refresh_token) {
        return this.postTokenAndSave({ grantType: "refresh_token", refreshToken: currToken.refresh_token });
    } else if (this.deviceId) {
        return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
    }
    return Promise.reject("Can not refresh token");
  }
  private getCookie(cname: string) {
    const name = cname + "=";
    const decodedCookie = decodeURIComponent(document.cookie);
    const ca = decodedCookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) === " ") {
        c = c.substring(1);
      }
      if (c.indexOf(name) === 0) {
        return c.substring(name.length, c.length);
      }
    }
    return "";
  }
  private setCookie(cname: string, cvalue: string, exdays: number) {
    const d = new Date();
    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
    const expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }
  public postTokenAndSave(params?: {grantType: string, username?: string, password?: string, deviceId?: string, refreshToken?: string}, options?: any) {
    this.deleteSavedToken();
    return new Promise((resolve: any, reject: any) => {
      const newParams: any = Object.assign({}, this.gatherCommonHeaders(params));
      const request = this.postToken(newParams, options);
      request.then((newToken: AccessToken) => {
        this.writeToken(newToken);
        resolve();
      })
      .catch ((e: any) => {
        console.error("Error in postToken from postTokenAndSave", e);
        reject(e);
      });
    });
  }
  /**
  * List AR-available actors
  * Returns the list of actors which are ready for AR analysis on an optional subset of movies
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param acceptLanguage Client locale, as language-country
  * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
  */
  public getARActors(params: {  "movieIds"?: Array<string>; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Array<ARCatalogPerson>>((resolve: any, reject: any) => {
      super.getARActors(newParams)
      .then((result: Array<ARCatalogPerson>) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getARActors", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getARActors")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getARActors(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * List AR-available context attributes
  * Returns the list of attributes and values on an optional subset of movies
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param acceptLanguage Client locale, as language-country
  * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
  */
  public getARAttributes(params: {  "movieIds"?: Array<string>; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Array<ARCatalogAttribute>>((resolve: any, reject: any) => {
      super.getARAttributes(newParams)
      .then((result: Array<ARCatalogAttribute>) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getARAttributes", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getARAttributes")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getARAttributes(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * List AR-available characters
  * Returns the list of characters which are ready for AR analysis on an optional subset of movies
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param acceptLanguage Client locale, as language-country
  * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
  */
  public getARCharacters(params: {  "movieIds"?: Array<string>; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Array<ARCatalogPerson>>((resolve: any, reject: any) => {
      super.getARCharacters(newParams)
      .then((result: Array<ARCatalogPerson>) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getARCharacters", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getARCharacters")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getARCharacters(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * List AR-available movies
  * Returns the list of movies which are ready for AR analysis
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param acceptLanguage Client locale, as language-country
  */
  public getARMovies(params: {  }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Array<ARCatalogMovie>>((resolve: any, reject: any) => {
      super.getARMovies(newParams)
      .then((result: Array<ARCatalogMovie>) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getARMovies", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getARMovies")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getARMovies(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * List serie seasons and chapters
  * Returns the list of seasons and chapters which are available for AR analysis for a given client serie
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param clientSerieId Client serie identifier
  * @param acceptLanguage Client locale, as language-country
  */
  public getARSerieSeasons(params: {  "clientSerieId": string; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Array<ARCatalogSerieSeason>>((resolve: any, reject: any) => {
      super.getARSerieSeasons(newParams)
      .then((result: Array<ARCatalogSerieSeason>) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getARSerieSeasons", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getARSerieSeasons")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getARSerieSeasons(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * List AR-available series
  * Returns the list of series which are ready for AR analysis
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param acceptLanguage Client locale, as language-country
  */
  public getARSeries(params: {  }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Array<ARCatalogSerie>>((resolve: any, reject: any) => {
      super.getARSeries(newParams)
      .then((result: Array<ARCatalogSerie>) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getARSeries", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getARSeries")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getARSeries(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * List AR-available taxonomies
  * Returns the list of taxonomies on an optional subset of movies
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param acceptLanguage Client locale, as language-country
  * @param movieIds Optional comma-separated list of movie IDs to filter returned taxonomies
  */
  public getARTaxonomies(params: {  "movieIds"?: Array<string>; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Array<ARCatalogCategory>>((resolve: any, reject: any) => {
      super.getARTaxonomies(newParams)
      .then((result: Array<ARCatalogCategory>) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getARTaxonomies", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getARTaxonomies")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getARTaxonomies(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Register user account
  * Registers a new user into Add Resonance application using the user name and provided password
  * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
  * @param registrationDataRequest User registration data
  */
  public postRegisterUser(params: {  "registrationDataRequest": RegistrationDataRequest; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<any>((resolve: any, reject: any) => {
      super.postRegisterUser(newParams)
      .then((result: any) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - postRegisterUser", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("postRegisterUser")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.postRegisterUser(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Search contexts at movie level
  * Returns the list of contexts which fulfill the search terms, filtered at movie level and grouped by taxonomy branch
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param acceptLanguage Client locale, as language-country
  * @param searchRequest Search terms
  */
  public postSearch(params: {  "searchRequest"?: ARSearchRequest; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Array<ARSearchResultCategory>>((resolve: any, reject: any) => {
      super.postSearch(newParams)
      .then((result: Array<ARSearchResultCategory>) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - postSearch", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("postSearch")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.postSearch(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Search contexts at scene level
  * Returns the list of scenes which fulfill the requested search filters, grouped by movie
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param acceptLanguage Client locale, as language-country
  * @param searchRequest Search terms
  */
  public postSearchScenes(params: {  "searchRequest"?: ARSearchRequest; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Array<ARSearchResultMovie>>((resolve: any, reject: any) => {
      super.postSearchScenes(newParams)
      .then((result: Array<ARSearchResultMovie>) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - postSearchScenes", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("postSearchScenes")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.postSearchScenes(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Token endpoint
  * The token endpoint is used to obtain access tokens which allow clients to make API requests
  * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
  * @param grantType Grant type used to obtain the token
  * @param acceptLanguage Client locale, as language-country
  * @param username User name
  * @param password User password
  * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
  */
  public postToken(params: {  "username"?: string; "password"?: string; "refreshToken"?: string; "grantType": string; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<AccessToken>((resolve: any, reject: any) => {
      super.postToken(newParams)
      .then((result: AccessToken) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - postToken", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("postToken")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.postToken(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Token endpoint
  * Registers a user into Dive apis using the client_id, user name and provided password
  * @param tokenDataRequest User registration data
  */
  public postTokenClientUser(params: {  "tokenDataRequest": ClientRegistrationDataRequest; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<AccessToken>((resolve: any, reject: any) => {
      super.postTokenClientUser(newParams)
      .then((result: AccessToken) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - postTokenClientUser", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("postTokenClientUser")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.postTokenClientUser(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  private serviceRequiresToken(methodName: string) {
    return this.noAuthServices.indexOf(methodName) === -1;
  }
}
