/// <reference types="node" />
/**
 * Dive AR REST API
 * Dive Ad Resonance REST API provides a set of services which leverage obtaining client catalog info and its related contexts and situations data
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://rest.dive.tv/v1".replace(/\/+$/, "");

export type TokenStoreType = "webstorage" | "cookies";

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: any;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
}

/**
 * Catalog movie information
 */
export interface ARMovie {
    /**
     * Movie identifier for the requester client
     */
    "client_movie_id": string;
    /**
     * Movie title in the request locale
     */
    "title": string;
    /**
     * Year of production
     */
    "year": number;
    /**
     * Name or names of the movie director(s)
     */
    "director": string;
}

/**
 * Context search results category
 */
export interface ARSearchResultCategory {
    /**
     * Result category name
     */
    "category": string;
    /**
     * List of taxonomies detected for this category
     */
    "taxonomies": Array<ARSearchResultTaxonomy>;
}

/**
 * Context search results movie context
 */
export interface ARSearchResultContext {
    /**
     * Context start timestamp in seconds
     */
    "start_ts": number;
    /**
     * Context end timestamp in seconds
     */
    "end_ts": number;
    /**
     * List of key frame image URLs for this context
     */
    "kfts": Array<string>;
    /**
     * Additional attributes related to this context
     */
    "attributes"?: any;
}

/**
 * Additional attributes linked to a detected context
 */
export interface ARSearchResultContextAttributes {
    /**
     * Generic name for the context
     */
    "name"?: string;
    /**
     * Detected object brand
     */
    "brand"?: string;
    /**
     * Detected object model
     */
    "model"?: string;
    /**
     * Year(s) of production of a detected object
     */
    "year"?: string;
    /**
     * Name of the author of an artistic or cultural item
     */
    "author"?: string;
    /**
     * Name of the performing artist of a song
     */
    "artist"?: string;
    /**
     * Name of the performer of a song
     */
    "performer"?: string;
    /**
     * Country where a location belongs
     */
    "country"?: string;
    /**
     * City where a location belongs
     */
    "city"?: string;
    /**
     * Region where a location belongs
     */
    "region"?: string;
    /**
     * Street address of a location
     */
    "street"?: string;
}

/**
 * Context search results movie
 */
export interface ARSearchResultMovie {
    /**
     * Movie identifier for the client
     */
    "client_movie_id": string;
    /**
     * Movie title in the request locale
     */
    "title": string;
    /**
     * Movie video location URL
     */
    "video_url": string;
    /**
     * Indicates if detected media is a movie or a chapter
     */
    "is_chapter"?: boolean;
    /**
     * Index of the season where this chapter belongs, only if is_chapter = true
     */
    "season_index"?: number;
    /**
     * Index of this chapter amongst season chapters, only if is_chapter = true
     */
    "chapter_index"?: number;
    /**
     * Title of the serie where this chapter belongs, only if is_chapter = true
     */
    "serie_title"?: string;
    /**
     * List of contexts detected on this movie related to the parent taxonomy
     */
    "contexts": Array<ARSearchResultContext>;
}

/**
 * Context search results taxonomy item
 */
export interface ARSearchResultTaxonomy {
    /**
     * Taxonomy ID
     */
    "tx_id": string;
    /**
     * Taxonomy friendly name
     */
    "name": string;
    /**
     * List of taxonomy nodes traversed from the root to this item
     */
    "breadcrumb": Array<string>;
    /**
     * List of movies where this taxonomy has been detected
     */
    "movies": Array<ARSearchResultMovie>;
}

/**
 * Catalog serie information
 */
export interface ARSerie {
    /**
     * Serie identifier for the requester client
     */
    "client_serie_id": string;
    /**
     * Serie title in the request locale
     */
    "title": string;
    /**
     * Year of production for first season
     */
    "year": number;
    /**
     * Name or names of the serie creator(s)
     */
    "creators": string;
    /**
     * Number of available seasons
     */
    "season_count": number;
}

/**
 * Catalog serie chapter information
 */
export interface ARSerieChapter {
    /**
     * Index of the chapter amongst season chapters, starting from 1
     */
    "chapter_index": number;
    /**
     * Movie ID for this chapter
     */
    "client_movie_id": string;
    /**
     * Chapter title in the requested locale
     */
    "title": string;
}

/**
 * Catalog serie seasons information
 */
export interface ARSerieSeason {
    /**
     * Index of the season amongst serie seasons, starting from 1
     */
    "season_index": number;
    /**
     * List of chapters of the season
     */
    "chapters": Array<ARSerieChapter>;
}

/**
 * API access token
 */
export interface AccessToken {
    /**
     * Auth token, must be included on every API request
     */
    "access_token"?: string;
    /**
     * Token type
     */
    "token_type"?: AccessTokenTokenTypeEnum;
    /**
     * Allows to issue new access tokens without resending client credentials
     */
    "refresh_token"?: string;
    /**
     * Expiration time (in seconds).
     */
    "expires_in"?: number;
    /**
     * Granted auth scope
     */
    "scope"?: AccessTokenScopeEnum;
}

export type AccessTokenTokenTypeEnum = "bearer";
export type AccessTokenScopeEnum = "device";
/**
 * Authentication error description
 */
export interface AuthError {
    /**
     * Short error identifier
     */
    "error"?: string;
    /**
     * Extended error description
     */
    "error_description"?: string;
}

/**
 * User registration data request
 */
export interface RegistrationDataRequest {
    /**
     * User name
     */
    "username": string;
    /**
     * User password in MD5 format
     */
    "password": string;
}



/**
 * DefaultApi - fetch parameter creator
 */
export const DefaultApiFetchParamCreator = {
    /**
     * Returns the list of movies which are ready for AR analysis
     * @summary List AR-available movies
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     */
    getARMovies(params: {  "authorization": string; "acceptLanguage"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getARMovies");
        }
        const baseUrl = `/ar/movies`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns the list of seasons and chapters which are available for AR analysis for a given client serie
     * @summary List serie seasons and chapters
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientSerieId Client serie identifier
     * @param acceptLanguage Client locale, as language-country
     */
    getARSerieSeasons(params: {  "authorization": string; "clientSerieId": string; "acceptLanguage"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getARSerieSeasons");
        }
        // verify required parameter "clientSerieId" is set
        if (params["clientSerieId"] == null) {
            throw new Error("Missing required parameter clientSerieId when calling getARSerieSeasons");
        }
        const baseUrl = `/ar/series/{client_serie_id}/seasons`
            .replace(`{${"client_serie_id"}}`, `${ params["clientSerieId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns the list of series which are ready for AR analysis
     * @summary List AR-available series
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     */
    getARSeries(params: {  "authorization": string; "acceptLanguage"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getARSeries");
        }
        const baseUrl = `/ar/series`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns the list of contextual items found after filtering by movie ID and context ID
     * @summary Search contextual items
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param movieIds Comma-separated list of movie IDs subset where search shoould be performed
     * @param taxonomyIds Comma-separated list of the taxonomy IDs subset that should be returned by the search query
     */
    getSearch(params: {  "authorization": string; "acceptLanguage"?: string; "movieIds"?: string; "taxonomyIds"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getSearch");
        }
        const baseUrl = `/ar/search`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = Object.assign({}, urlObj.query, {
            "movie_ids": params["movieIds"],
            "taxonomy_ids": params["taxonomyIds"],
        });
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Registers a new user into Add Resonance application using the user name and provided password
     * @summary Register user account
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param registrationDataRequest User registration data
     */
    postRegisterUser(params: {  "authorization": string; "registrationDataRequest": RegistrationDataRequest; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling postRegisterUser");
        }
        // verify required parameter "registrationDataRequest" is set
        if (params["registrationDataRequest"] == null) {
            throw new Error("Missing required parameter registrationDataRequest when calling postRegisterUser");
        }
        const baseUrl = `/ar/register/user`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["registrationDataRequest"]) {
            fetchOptions.body = JSON.stringify(params["registrationDataRequest"] || {});
        }
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * The token endpoint is used to obtain access tokens which allow clients to make API requests
     * @summary Token endpoint
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param grantType Grant type used to obtain the token
     * @param acceptLanguage Client locale, as language-country
     * @param username User name
     * @param password User password
     * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
     */
    postToken(params: {  "authorization": string; "grantType": string; "acceptLanguage"?: string; "username"?: string; "password"?: string; "refreshToken"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling postToken");
        }
        // verify required parameter "grantType" is set
        if (params["grantType"] == null) {
            throw new Error("Missing required parameter grantType when calling postToken");
        }
        const baseUrl = `/token`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = Object.assign({}, urlObj.query, {
            "grant_type": params["grantType"],
        });
        let fetchOptions: RequestInit = Object.assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "username": params["username"],
            "password": params["password"],
            "refresh_token": params["refreshToken"],
        });
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = {
    /**
     * Returns the list of movies which are ready for AR analysis
     * @summary List AR-available movies
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     */
    getARMovies(params: { "authorization": string; "acceptLanguage"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Array<ARMovie>> {
        const fetchArgs = DefaultApiFetchParamCreator.getARMovies(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns the list of seasons and chapters which are available for AR analysis for a given client serie
     * @summary List serie seasons and chapters
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientSerieId Client serie identifier
     * @param acceptLanguage Client locale, as language-country
     */
    getARSerieSeasons(params: { "authorization": string; "clientSerieId": string; "acceptLanguage"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Array<ARSerieSeason>> {
        const fetchArgs = DefaultApiFetchParamCreator.getARSerieSeasons(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns the list of series which are ready for AR analysis
     * @summary List AR-available series
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     */
    getARSeries(params: { "authorization": string; "acceptLanguage"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Array<ARSerie>> {
        const fetchArgs = DefaultApiFetchParamCreator.getARSeries(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns the list of contextual items found after filtering by movie ID and context ID
     * @summary Search contextual items
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param movieIds Comma-separated list of movie IDs subset where search shoould be performed
     * @param taxonomyIds Comma-separated list of the taxonomy IDs subset that should be returned by the search query
     */
    getSearch(params: { "authorization": string; "acceptLanguage"?: string; "movieIds"?: string; "taxonomyIds"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Array<ARSearchResultCategory>> {
        const fetchArgs = DefaultApiFetchParamCreator.getSearch(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Registers a new user into Add Resonance application using the user name and provided password
     * @summary Register user account
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param registrationDataRequest User registration data
     */
    postRegisterUser(params: { "authorization": string; "registrationDataRequest": RegistrationDataRequest;  }, options?: any): (fetch?: any, basePath?: string) => Promise<any> {
        const fetchArgs = DefaultApiFetchParamCreator.postRegisterUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * The token endpoint is used to obtain access tokens which allow clients to make API requests
     * @summary Token endpoint
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param grantType Grant type used to obtain the token
     * @param acceptLanguage Client locale, as language-country
     * @param username User name
     * @param password User password
     * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
     */
    postToken(params: { "authorization": string; "grantType": string; "acceptLanguage"?: string; "username"?: string; "password"?: string; "refreshToken"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = DefaultApiFetchParamCreator.postToken(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * Returns the list of movies which are ready for AR analysis
     * @summary List AR-available movies
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     */
    getARMovies(params: {  "authorization": string; "acceptLanguage"?: string; }, options?: any) {
        return DefaultApiFp.getARMovies(params, options)(this.fetch, this.basePath);
    }
    /**
     * Returns the list of seasons and chapters which are available for AR analysis for a given client serie
     * @summary List serie seasons and chapters
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientSerieId Client serie identifier
     * @param acceptLanguage Client locale, as language-country
     */
    getARSerieSeasons(params: {  "authorization": string; "clientSerieId": string; "acceptLanguage"?: string; }, options?: any) {
        return DefaultApiFp.getARSerieSeasons(params, options)(this.fetch, this.basePath);
    }
    /**
     * Returns the list of series which are ready for AR analysis
     * @summary List AR-available series
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     */
    getARSeries(params: {  "authorization": string; "acceptLanguage"?: string; }, options?: any) {
        return DefaultApiFp.getARSeries(params, options)(this.fetch, this.basePath);
    }
    /**
     * Returns the list of contextual items found after filtering by movie ID and context ID
     * @summary Search contextual items
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param movieIds Comma-separated list of movie IDs subset where search shoould be performed
     * @param taxonomyIds Comma-separated list of the taxonomy IDs subset that should be returned by the search query
     */
    getSearch(params: {  "authorization": string; "acceptLanguage"?: string; "movieIds"?: string; "taxonomyIds"?: string; }, options?: any) {
        return DefaultApiFp.getSearch(params, options)(this.fetch, this.basePath);
    }
    /**
     * Registers a new user into Add Resonance application using the user name and provided password
     * @summary Register user account
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param registrationDataRequest User registration data
     */
    postRegisterUser(params: {  "authorization": string; "registrationDataRequest": RegistrationDataRequest; }, options?: any) {
        return DefaultApiFp.postRegisterUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * The token endpoint is used to obtain access tokens which allow clients to make API requests
     * @summary Token endpoint
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param grantType Grant type used to obtain the token
     * @param acceptLanguage Client locale, as language-country
     * @param username User name
     * @param password User password
     * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
     */
    postToken(params: {  "authorization": string; "grantType": string; "acceptLanguage"?: string; "username"?: string; "password"?: string; "refreshToken"?: string; }, options?: any) {
        return DefaultApiFp.postToken(params, options)(this.fetch, this.basePath);
    }
}

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (fetch?: any, basePath?: string) {
    return {
        /**
         * Returns the list of movies which are ready for AR analysis
         * @summary List AR-available movies
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param acceptLanguage Client locale, as language-country
         */
        getARMovies(params: {  "authorization": string; "acceptLanguage"?: string; }, options?: any) {
            return DefaultApiFp.getARMovies(params, options)(fetch, basePath);
        },
        /**
         * Returns the list of seasons and chapters which are available for AR analysis for a given client serie
         * @summary List serie seasons and chapters
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param clientSerieId Client serie identifier
         * @param acceptLanguage Client locale, as language-country
         */
        getARSerieSeasons(params: {  "authorization": string; "clientSerieId": string; "acceptLanguage"?: string; }, options?: any) {
            return DefaultApiFp.getARSerieSeasons(params, options)(fetch, basePath);
        },
        /**
         * Returns the list of series which are ready for AR analysis
         * @summary List AR-available series
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param acceptLanguage Client locale, as language-country
         */
        getARSeries(params: {  "authorization": string; "acceptLanguage"?: string; }, options?: any) {
            return DefaultApiFp.getARSeries(params, options)(fetch, basePath);
        },
        /**
         * Returns the list of contextual items found after filtering by movie ID and context ID
         * @summary Search contextual items
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param acceptLanguage Client locale, as language-country
         * @param movieIds Comma-separated list of movie IDs subset where search shoould be performed
         * @param taxonomyIds Comma-separated list of the taxonomy IDs subset that should be returned by the search query
         */
        getSearch(params: {  "authorization": string; "acceptLanguage"?: string; "movieIds"?: string; "taxonomyIds"?: string; }, options?: any) {
            return DefaultApiFp.getSearch(params, options)(fetch, basePath);
        },
        /**
         * Registers a new user into Add Resonance application using the user name and provided password
         * @summary Register user account
         * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
         * @param registrationDataRequest User registration data
         */
        postRegisterUser(params: {  "authorization": string; "registrationDataRequest": RegistrationDataRequest; }, options?: any) {
            return DefaultApiFp.postRegisterUser(params, options)(fetch, basePath);
        },
        /**
         * The token endpoint is used to obtain access tokens which allow clients to make API requests
         * @summary Token endpoint
         * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
         * @param grantType Grant type used to obtain the token
         * @param acceptLanguage Client locale, as language-country
         * @param username User name
         * @param password User password
         * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
         */
        postToken(params: {  "authorization": string; "grantType": string; "acceptLanguage"?: string; "username"?: string; "password"?: string; "refreshToken"?: string; }, options?: any) {
            return DefaultApiFp.postToken(params, options)(fetch, basePath);
        },
    };
};

/**
* CustomAPI - extended object-oriented interface
*/
export class CustomAPI extends DefaultApi {
  public locale: string;
  private apiKey: string;
  private deviceId: string;
  private environment: string = "PRO";
  private storeTokenType: TokenStoreType = "webstorage";
  private tokenName: string = "dive_token";
  private diveTokenRefreshInterval: number | undefined;
  private noAuthServices: string[] = [];

  constructor(params: { environment: "DEV" | "PRE" | "PRO", tokenName?: string, storeToken?: TokenStoreType, apiKey: string, deviceId?: string, fetch?: any } = { environment: "PRO", storeToken: "webstorage", tokenName: "dive_token", apiKey: ""}) {
    super(params.fetch, BASE_PATH);
    if (params.apiKey === "") {
      console.error("You should provide an apiKey in the params");
      throw new Error("You should provide an apiKey in the params");
    }
    this.apiKey = params.apiKey;
    if (params.deviceId) {
        this.setDeviceId(params.deviceId);
    }
    if (params.environment) {
      this.setEnvironment(params.environment);
    }
    if (params.storeToken) {
      this.storeTokenType = params.storeToken;
    }
    if (params.tokenName) {
      this.tokenName = params.tokenName;
    }
  }

  public setDeviceId(deviceId: string) {
    this.deviceId = deviceId;
  }

  public setEnvironment(env: "DEV" | "PRE" | "PRO") {
    this.environment = env;
    switch (env) {
        case "DEV":
            this.basePath = BASE_PATH.replace("https://", "https://dev-");
        break;
        case "PRE":
            this.basePath = BASE_PATH.replace("https://", "https://pre-");
        break;
        case "PRO":
        default:
            this.basePath = BASE_PATH;
        break;
    }
  }
  public setLocale(locale: string) {
      this.locale = locale;
  }
  public getLocale() {
      return this.locale;
  }
  public gatherCommonHeaders(params?: any) {
    const newParams: any = {};
    if (!params) {
        params = {};
    }
    if (params["connection"] == null) {
        newParams.connection = "keep-alive";
    }
    if (params["acceptEncoding"] == null) {
        newParams.acceptEncoding = "gzip, deflate";
    }
    if (params["authorization"] == null && this.getSavedToken()) {
        newParams.authorization = `${this.getSavedToken().token_type.substring(0,1).toUpperCase()}${this.getSavedToken().token_type.substring(1)} ${this.getSavedToken().access_token}`;
    } else {
        newParams.authorization = `Basic ${this.apiKey}`;
    }
    if (params.acceptLanguage == null && this.locale !== null) {
        newParams.acceptLanguage = this.locale;
    }
    if (params["Accept-Language"] == null && this.locale !== null) {
        newParams["Accept-Language"] = this.locale;
    }
    return Object.assign({}, newParams, params);
  }
  public writeToken(newToken: AccessToken) {
    if (newToken) {
      switch (this.storeTokenType) {
        case "cookies":
          this.writeTokenToCookie(newToken);
          break;
        default:
          this.writeTokenToWebStorage(newToken);
          break;
      }
      if (this.diveTokenRefreshInterval) {
        window.clearInterval(this.diveTokenRefreshInterval);
        this.diveTokenRefreshInterval = undefined;
      }
      if (newToken.expires_in) {
        this.diveTokenRefreshInterval = window.setInterval(this.refreshToken.bind(this), (Math.max(10000, newToken.expires_in - 60) * 1000) as any); // 60 seconds before expiration (in ms)
      }
    }
  }
  private writeTokenToCookie(newToken: AccessToken) {
    return this.setCookie(this.tokenName, JSON.stringify(newToken), newToken.expires_in!);
  }
  private writeTokenToWebStorage(newToken: AccessToken) {
    if (window.localStorage) {
      window.localStorage.setItem(this.tokenName, JSON.stringify(newToken));
    }
  }
  public deleteSavedToken() {
    switch (this.storeTokenType) {
      case "cookies":
        this.deleteTokenFromCookies();
        break;
      default:
        this.deleteTokenFromWebStorage();
        break;
    }
  }
  private deleteTokenFromWebStorage() {
      if (window.localStorage) {
          window.localStorage.removeItem(this.tokenName);
      }
  }
  private deleteTokenFromCookies() {
    document.cookie = this.tokenName + "=;expires=Thu, 01 Jan 1970 00:00:01 GMT;";
  }
  public getSavedToken() {
    switch (this.storeTokenType) {
      case "cookies":
        return this.getTokenFromCookies();
      default:
        if (this.getTokenFromWebStorage()) {
            return JSON.parse(this.getTokenFromWebStorage() as string);
        }
        break;
    }
  }
  private getTokenFromCookies(): AccessToken | undefined | null {
    const token = this.getCookie(this.tokenName);
    if (token) {
      try {
          return JSON.parse(token) as AccessToken;
      } catch (e) {
          return undefined;
      }
    } else {
      return undefined;
    }
  }
  private getTokenFromWebStorage(): AccessToken | undefined | null {
    if (window.localStorage) {
      try {
        return window.localStorage.getItem(this.tokenName) as AccessToken;
      } catch (e) {
        return undefined;
      }
    }
  }
  public refreshToken() {
    const currToken = this.getSavedToken();
    let auth: string = `Basic ${this.apiKey}`;
    if (currToken && currToken.refresh_token) {
        return this.postTokenAndSave({ grantType: "refresh_token", refreshToken: currToken.refresh_token });
    } else if (this.deviceId) {
        return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
    }
    return Promise.reject("Can not refresh token");
  }
  private getCookie(cname: string) {
    const name = cname + "=";
    const decodedCookie = decodeURIComponent(document.cookie);
    const ca = decodedCookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) === " ") {
        c = c.substring(1);
      }
      if (c.indexOf(name) === 0) {
        return c.substring(name.length, c.length);
      }
    }
    return "";
  }
  private setCookie(cname: string, cvalue: string, exdays: number) {
    const d = new Date();
    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
    const expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }
  public postTokenAndSave(params?: {grantType: string, username?: string, password?: string, deviceId?: string, refreshToken?: string}, options?: any) {
    this.deleteSavedToken();
    return new Promise((resolve: any, reject: any) => {
      const newParams: any = Object.assign({}, this.gatherCommonHeaders(params));
      const request = this.postToken(newParams, options);
      request.then((newToken: AccessToken) => {
        this.writeToken(newToken);
        resolve();
      })
      .catch ((e: any) => {
        console.error("Error in postToken from postTokenAndSave", e);
      });
    });
  }
  /**
  * List AR-available movies
  * Returns the list of movies which are ready for AR analysis
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param acceptLanguage Client locale, as language-country
  */
  public getARMovies(params: {  }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Array<ARMovie>>((resolve: any, reject: any) => {
      super.getARMovies(newParams)
      .then((result: Array<ARMovie>) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getARMovies", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getARMovies")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getARMovies(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * List serie seasons and chapters
  * Returns the list of seasons and chapters which are available for AR analysis for a given client serie
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param clientSerieId Client serie identifier
  * @param acceptLanguage Client locale, as language-country
  */
  public getARSerieSeasons(params: {  "clientSerieId": string; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Array<ARSerieSeason>>((resolve: any, reject: any) => {
      super.getARSerieSeasons(newParams)
      .then((result: Array<ARSerieSeason>) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getARSerieSeasons", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getARSerieSeasons")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getARSerieSeasons(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * List AR-available series
  * Returns the list of series which are ready for AR analysis
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param acceptLanguage Client locale, as language-country
  */
  public getARSeries(params: {  }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Array<ARSerie>>((resolve: any, reject: any) => {
      super.getARSeries(newParams)
      .then((result: Array<ARSerie>) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getARSeries", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getARSeries")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getARSeries(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Search contextual items
  * Returns the list of contextual items found after filtering by movie ID and context ID
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param acceptLanguage Client locale, as language-country
  * @param movieIds Comma-separated list of movie IDs subset where search shoould be performed
  * @param taxonomyIds Comma-separated list of the taxonomy IDs subset that should be returned by the search query
  */
  public getSearch(params: {  "movieIds"?: string; "taxonomyIds"?: string; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Array<ARSearchResultCategory>>((resolve: any, reject: any) => {
      super.getSearch(newParams)
      .then((result: Array<ARSearchResultCategory>) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getSearch", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getSearch")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getSearch(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Register user account
  * Registers a new user into Add Resonance application using the user name and provided password
  * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
  * @param registrationDataRequest User registration data
  */
  public postRegisterUser(params: {  "registrationDataRequest": RegistrationDataRequest; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<any>((resolve: any, reject: any) => {
      super.postRegisterUser(newParams)
      .then((result: any) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - postRegisterUser", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("postRegisterUser")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.postRegisterUser(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Token endpoint
  * The token endpoint is used to obtain access tokens which allow clients to make API requests
  * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
  * @param grantType Grant type used to obtain the token
  * @param acceptLanguage Client locale, as language-country
  * @param username User name
  * @param password User password
  * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
  */
  public postToken(params: {  "username"?: string; "password"?: string; "refreshToken"?: string; "grantType": string; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<AccessToken>((resolve: any, reject: any) => {
      super.postToken(newParams)
      .then((result: AccessToken) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - postToken", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("postToken")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.postToken(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  private serviceRequiresToken(methodName: string) {
    return this.noAuthServices.indexOf(methodName) === -1;
  }
}
